// THIS FILE IS GENERATED, DO NOT EDIT


//! A wrapper around the HID Usage Tables (HUT). For reference, see the 
//! [HID Usage Tables](https://usb.org/document-library/hid-usage-tables-15).
//! Note that this module is created through code generation.
//!
//! In this document and unless stated otherwise, a reference to "section a.b.c" refers to the 
//! [HID Device Class Definition for HID 1.11](https://www.usb.org/document-library/device-class-definition-hid-111).
//!
//! # Terminology
//! 
//! See Section 5.5: a HID Usage is a 32 bit value comprising of a 16-bit Usage
//! Page and a 16-bit Usage ID so that: 
//! ```
//! let usage_page: u16 = 0x01; // Generic Desktop
//! let usage_id: u16 = 0x02; // Mouse
//! let usage: u32 = (usage_page as u32) << 16 | usage_id as u32;
//! 
//! let u = GenericDesktop::Mouse;
//! assert!(usage == u.usage());
//! ```
//! In this module:
//! - "Usage Page" refers to the 16-bit value. Where the Usage Page is converted
//!   to or from a 32-bit value the Usage Page is in the upper 16 bits of that value and
//!   the lower 16 bits are ignored or set to zero.
//! - "Usage ID" refers to the 16-bit value. Where the Usage ID is converted to
//!   or from a 32-bit value the Usage is in the lower 16 bits of that value and !   the upper 16 bits are ignored or set to zero.
//! - "Usage" refers to the 32-bit value comprising a Usage Page and a Usage.

//! # Button Usage Page
//!
//! The [Button Usage Page](Button) and [Usages](Button::Button) are not autogenerated and thus
//! follow a different approach: the Usage inside the Usage Page is a simple
//! numeric usage that needs to be destructured in `match` statements.
//!
//! # Vendor Defined Usage Pages
//!
//! [Vendor Defined Usage Pages](VendorDefinedPage1) and [Usages](VendorDefinedPage1::VendorUsage) are not autogenerated and thus
//! follow a different approach: the Usage inside the Usage Page is a simple
//! numeric usage that needs to be destructured in `match` statements.
//!
//! # Renames
//!
//! For technical reasons, spaces, (` `), dashes (`-`), and slashes (`/`) are
//! stripped out of Usage Page and Usage names. The string representation via
//! the `Display` trait will have the unmodified value.
//!
//! Usage Pages and Usages starting with a number are translated into their
//! English word, for example [GamingControls::ThreeDGameController]. Numbers
//! inside a word are left as-is.


use thiserror::Error;
use std::fmt;
use std::ops::BitOr;

use crate::Usage as HidUsage;
use crate::hid;
use crate::types;

#[derive(Error, Debug)]
pub enum HutError {
    #[error("Unknown Usage Page {usage_page}")]
    UnknownUsagePage { usage_page: u16 },
    #[error("Unknown Usage")]
    UnknownUsage,
}

type Result<T> = std::result::Result<T, HutError>;

/// A HID UsagePage, see section 5.5. This represents the upper 16 bits in the 
/// 32-bit
///
/// Note: this enum is generated from the HUT documents.
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum UsagePage {
    {% for usage_page in usage_pages %}
    /// Usage Page `0x{{usage_page.value| int(usage_page.value, 16)}}`: "{{usage_page.printable}}"
    ///
    /// See [{{usage_page.name}}].
    {{usage_page.name}},
    {% endfor %}
    /// The Vendor Defined Page. See [VendorDefinedPage1].
    VendorDefinedPage1,
}

impl UsagePage {
    /// Returns the Usage Page for the given Usage Page value. This is the
    /// 16-bit Usage Page value only, not the full 32-bit Usage.
    ///
    /// The returned value is always the "Undefined" usage of the matching 
    /// Usage Page.
    pub fn from_usage_page_value(usage_page: u16) -> Result<UsagePage> {
        UsagePage::try_from(usage_page)
    }

    /// Returns the Usage Page for the given Usage numeric value. The Usage Page
    /// must be in the upper 16 bits of the `usage` value and the lower 16 bits
    /// are ignored.
    pub fn from_usage_value(usage: u32) -> Result<UsagePage> {
        let up: u16 = (usage >> 16) as u16;
        UsagePage::try_from(up)
    }

    /// Returns the 16-bit value for this Usage Page.
    pub fn usage_page(&self) -> u16 {
        u16::try_from(self).unwrap()
    }

    /// Returns the 32-bit Usage that is this Usage Page combined with
    /// the 16 bits Usage ID.
    pub fn to_usage_from_value(&self, usage: u16) -> Result<Usage> {
        let up: u32 = (self.usage_page() as u32) << 16;
        let u: u32 = usage as u32;
        Usage::try_from(up | u)
    }

    pub fn to_usage(&self, usage: &types::UsageId) -> Result<Usage> {
        let up: u32 = (self.usage_page() as u32) << 16;
        let u: u32 = u16::from(usage) as u32;
        Usage::try_from(up | u)
    }
}

{% for usage_page in usage_pages %}
{% if usage_page.name != "VendorDefinedPage1" and usage_page.name != "Button" %}
/// Usage Page `0x{{usage_page.value| int(usage_page.value, 16)}}`: "{{usage_page.printable}}"
///
/// **This enum is autogenerated from the HID Usage Tables**.
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum {{usage_page.name}} {
{% for usage in usage_page.usages %}
    /// Usage ID `0x{{usage.value|int(usage.value, 16)}}`: "{{usage.printable}}"
    {{ usage.name }},
{% endfor %}
}

impl fmt::Display for {{usage_page.name}} {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
{% for usage in usage_page.usages %}
            {{usage_page.name}}::{{usage.name}} => "{{usage.printable}}",
{% else %}
            _ => "",
{% endfor %}
        };
        write!(f, "{name}")
    }
}

{% endif %}
{% endfor %}

/// Usage Page `0x9`: "Button"
///
/// This Usage Page has only one named Usage ID, any Usages IDs in this Usage
/// Page are simply the button number.
#[derive(Debug)]
#[non_exhaustive]
pub enum Button {
    /// Usage ID `0x0`: "No Buttons Pressed"
    NoButtonsPressed,
    Button { button: u16 },
}

impl fmt::Display for Button {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
            Button::NoButtonsPressed  => format!("No Buttons Pressed"),
            Button::Button { button } => format!("Button {button}"),
        };
        write!(f, "{name}")
    }
}

/// Usage Page `0xff00`: The Vendor Defined Page
///
/// This Usage Page has no named Usage IDs, any Usages in this Usage Page are
/// private to a vendor implementation.
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum VendorDefinedPage1 {
    Undefined,
    VendorUsage { usage_id: u16 },
}

impl fmt::Display for VendorDefinedPage1 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
            VendorDefinedPage1::Undefined  => format!("Vendor Usage Undefined"),
            VendorDefinedPage1::VendorUsage { usage_id } => format!("Vendor Usage 0x{usage_id:02x}"),
        };
        write!(f, "{name}")
    }
}

impl From<&Usage> for UsagePage {
    fn from(usage: &Usage) -> UsagePage {
        match usage {
{% for usage_page in usage_pages %}
            Usage::{{usage_page.name}} { .. } => UsagePage::{{usage_page.name}},
{% endfor %}
            Usage::VendorDefinedPage1 { .. }  => UsagePage::VendorDefinedPage1,
        }
    }
}

impl TryFrom<&UsagePage> for u16 {
    type Error = HutError;

    /// Returns the UsagePage as 16-bit value. This is equivalent to the
    /// upper 16 bits of a full 32-bit Usage value shifted down.
    fn try_from(usage_page: &UsagePage) -> Result<u16> {
        match usage_page {
{% for usage_page in usage_pages %}
            UsagePage::{{usage_page.name}} { .. } => Ok({{usage_page.value}}),
{% endfor %}
            UsagePage::VendorDefinedPage1 { .. }  => Ok(0xff00),
        }
    }
}

impl TryFrom<u16> for UsagePage {
    type Error = HutError;

    fn try_from(usage_page: u16) -> Result<UsagePage> {
        match usage_page {
{% for usage_page in usage_pages %}
            {{usage_page.value}} => Ok(UsagePage::{{usage_page.name}}),
{% endfor %}
            0xff00 => Ok(UsagePage::VendorDefinedPage1),
            n => Err(HutError::UnknownUsagePage { usage_page: n }),
        }
    }
}

impl TryFrom<&types::UsagePage> for UsagePage {
    type Error = HutError;

    fn try_from(usage_page: &types::UsagePage) -> Result<UsagePage> {
        let up: u16 = usage_page.into();
        UsagePage::from_usage_page_value(up)
    }
}

impl fmt::Display for UsagePage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
{% for usage_page in usage_pages %}
            UsagePage::{{usage_page.name}} => "{{usage_page.printable}}",
{% endfor %}
            UsagePage::VendorDefinedPage1 => "Vendor Defined Page 1",
        };
        write!(f, "{name}")
    }
}

{% for usage_page in usage_pages %}
impl From<{{usage_page.name}}> for u16 {
    fn from(up: {{usage_page.name}}) -> u16 {
        match up {
            {% for usage in usage_page.usages %}
            {{usage_page.name}}::{{usage.name}} => {{usage.value}},
            {% endfor %}
            {% if usage_page.name == "Button" %}
            Button::Button { button } => button,
            {% endif %}
        }
    }
}

impl BitOr<u16> for {{usage_page.name}} {
    type Output = Usage;

    /// A convenience function to combine a Usage Page with
    /// a value.
    ///
    /// This function panics if the Usage ID value results in
    /// an unknown Usage. Where error checking is required,
    /// use [UsagePage::to_usage].
    fn bitor(self, usage: u16) -> Self::Output {
        let up = u16::from(self) as u32;
        let u = usage as u32;
        Usage::try_from(up | u).expect("Invalid Usage ID for this Usage Page")
    }
}

{% endfor  %}

///
///
/// Note: this enum is generated from the HUT documents.
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum Usage {
    {% for usage_page in usage_pages %}
    /// "{{usage_page.printable}}"
    {{usage_page.name}} { usage: {{usage_page.name}} },
    {% endfor %}
    VendorDefinedPage1 { usage: VendorDefinedPage1 },
}

impl Usage {
    pub fn new_from_values(usage_page: u16, usage_id: u16) -> Result<Usage> {
        Usage::try_from((usage_page as u32) << 16 | usage_id as u32)
    }

    /// Returns the 32 bit Usage value for this usage.
    pub fn usage(&self) -> u32 {
        self.into()
    }
}

impl fmt::Display for Usage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
{% for usage_page in usage_pages %}
            Usage::{{usage_page.name}} { usage } => format!("{usage}"),
{%  else %}
            _ => "".into(),
{% endfor %}
            Usage::VendorDefinedPage1 { usage } => format!("{usage}"),
        };
        write!(f, "{name}")
    }
}

impl From<&Usage> for u16 {
    fn from(usage: &Usage) -> u16 {
        let u: u32 = u32::from(usage);
        (u & 0xFFFF) as u16
    }
}

impl From<Usage> for u16 {
    fn from(usage: Usage) -> u16 {
        u16::from(&usage)
    }
}

impl From<&Usage> for u32 {
    fn from(usage: &Usage) -> u32 {
        match usage {
{% for usage_page in usage_pages %}
{% for usage in usage_page.usages %}
            Usage::{{usage_page.name}} { usage: {{usage_page.name}}::{{usage.name}} } => {{usage_page.value}} << 16 | {{usage.value}},
{% endfor  %}
{% endfor  %}
            Usage::Button { usage: Button::Button { button } }  => 0x09 | *button as u32,
            Usage::VendorDefinedPage1 { usage: VendorDefinedPage1::Undefined } => 0xff000000,
            Usage::VendorDefinedPage1 { usage: VendorDefinedPage1::VendorUsage { usage_id } } => 0xff00000u32 | *usage_id as u32,
            _ => panic!("Unhandled usage {usage:?}"),
        }
    }
}

impl TryFrom<&HidUsage> for Usage {
    type Error = HutError;

    fn try_from(usage: &HidUsage) -> Result<Usage> {
        let up = u16::from(usage.usage_page);
        let u = u16::from(usage.usage_id);
        Usage::new_from_values(up, u)
    }
}

impl TryFrom<u32> for Usage {
    type Error = HutError;

    fn try_from(up: u32) -> Result<Usage> {
        match (up >> 16, up & 0xFFFF) {
{% for usage_page in usage_pages %}
{% for usage in usage_page.usages %}
            ({{usage_page.value}},  {{usage.value}}) => Ok(Usage::{{usage_page.name}} { usage: {{usage_page.name}}::{{usage.name}} }),
{% endfor  %}
{% endfor  %}
            (0x009, n) => Ok(Usage::Button { usage: Button::Button { button: n as u16 } }),
            (0xff00, n) => Ok(Usage::VendorDefinedPage1 { usage: VendorDefinedPage1::VendorUsage { usage_id: n as u16 } }),
            (_, _) => Err(HutError::UnknownUsage),
        }
    }
}
