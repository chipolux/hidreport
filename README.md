# hidreport

 This crate provides parsing of HID Report Descriptors, including the [hid] module to inspect
 a report descriptor in more detail. Check out the `hut` crate for known HID Usages to make
 sense of the various HID fields.

 Entry point is usually [`ReportDescriptor::try_from(bytes)`](ReportDescriptor::try_from):

 ```rust
 # use hidreport::*;
 # let bytes: &[u8] = &[0x05, 0x01, 0x09, 0x02, 0xa1, 0x01, 0x05, 0x01, 0x09, 0x02, 0xa1, 0x02, 0x85, 0x1a, 0x09, 0x01, 0xa1, 0x00, 0x05, 0x09, 0x19, 0x01, 0x29, 0x05, 0x95, 0x05, 0x75, 0x01, 0x15, 0x00, 0x25, 0x01, 0x81, 0x02, 0x75, 0x03, 0x95, 0x01, 0x81, 0x01, 0x05, 0x01, 0x09, 0x30, 0x09, 0x31, 0x95, 0x02, 0x75, 0x10, 0x16, 0x01, 0x80, 0x26, 0xff, 0x7f, 0x81, 0x06, 0xa1, 0x02, 0x85, 0x12, 0x09, 0x48, 0x95, 0x01, 0x75, 0x02, 0x15, 0x00, 0x25, 0x01, 0x35, 0x01, 0x45, 0x0c, 0xb1, 0x02, 0x85, 0x1a, 0x09, 0x38, 0x35, 0x00, 0x45, 0x00, 0x95, 0x01, 0x75, 0x10, 0x16, 0x01, 0x80, 0x26, 0xff, 0x7f, 0x81, 0x06, 0xc0, 0xa1, 0x02, 0x85, 0x12, 0x09, 0x48, 0x75, 0x02, 0x15, 0x00, 0x25, 0x01, 0x35, 0x01, 0x45, 0x0c, 0xb1, 0x02, 0x35, 0x00, 0x45, 0x00, 0x75, 0x04, 0xb1, 0x01, 0x85, 0x1a, 0x05, 0x0c, 0x95, 0x01, 0x75, 0x10, 0x16, 0x01, 0x80, 0x26, 0xff, 0x7f, 0x0a, 0x38, 0x02, 0x81, 0x06, 0xc0, 0xc0, 0xc0, 0xc0, 0x05, 0x0c, 0x09, 0x01, 0xa1, 0x01, 0x05, 0x01, 0x09, 0x02, 0xa1, 0x02, 0x85, 0x1f, 0x05, 0x0c, 0x0a, 0x38, 0x02, 0x95, 0x01, 0x75, 0x10, 0x16, 0x01, 0x80, 0x26, 0xff, 0x7f, 0x81, 0x06, 0x85, 0x17, 0x06, 0x00, 0xff, 0x0a, 0x06, 0xff, 0x0a, 0x0f, 0xff, 0x15, 0x00, 0x25, 0x01, 0x35, 0x01, 0x45, 0x0c, 0x95, 0x02, 0x75, 0x02, 0xb1, 0x02, 0x0a, 0x04, 0xff, 0x35, 0x00, 0x45, 0x00, 0x95, 0x01, 0x75, 0x01, 0xb1, 0x02, 0x75, 0x03, 0xb1, 0x01, 0xc0, 0xc0];
 # fn read_from_device() -> Vec<u8> {
 #     vec![0x1a, 0x00, 0xff, 0xff, 0xfe, 0xff, 00, 00, 00, 0x00]
 # }
 #
 let rdesc: ReportDescriptor = ReportDescriptor::try_from(bytes).unwrap();
 for r in rdesc.input_reports() {
     println!("Input Report with report ID: {:?}", r.report_id());
 }

 let input_report_bytes = read_from_device();
 let report = rdesc.find_input_report(&input_report_bytes).unwrap();
 println!("This is an input report for report ID: {:?}", report.report_id());
 let field = report.fields().first().unwrap();
 match field {
     Field::Variable(var) => {
         let val: u32 = var.extract_u32(&input_report_bytes).unwrap();
         println!("Field {:?} is of value {}", field, val);
     }
     Field::Array(arr) => {
         let vals: Vec<u32> = arr.extract_u32(&input_report_bytes).unwrap();
         println!("Field {:?} has values {:?}", field, vals);
     }
     Field::Constant(_) => {
         println!("Field {:?} is <padding data>", field);
     }
 }
 ```

 Note that this create does not concern itself with obtaining Hid Report Descriptors or HID Reports,
 it provides parsing facilities only.

# License

hidreport is [MIT-licensed](https://spdx.org/licenses/MIT.html), see the [COPYING](COPYING) file for details.
